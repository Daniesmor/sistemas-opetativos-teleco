char *
get_next_token(char *ptr, char *delimiter) {
	return strtok(ptr, delimiter);
}

char *
get_variable(char *found) {
	char *variable;

	variable = getenv(found);
	if (variable == NULL) {
		variable = ""; //SI LA VARIABLE NO EXISTE SE DEJA VACIA (ESTANDARES)
		printf("%ld\n", sizeof(variable));
	}	

	return variable;
}

void
write_newtoken(char **new_token,char *variable, char *ptr) {

	if (strcmp(variable, "") == 0) {
		strcpy(*new_token, ptr);
	} else {
		strcpy(*new_token, variable);
		strcat(*new_token, "/");
		strcat(*new_token, ptr);			
	}

}

void
remake_token(char **new_token, char * variable, char *ptr) {
	
	// AHORA DEBEMOS RECONSTRUIR EL TOKEN, CON LA VARIABLE DELIMITADA
		if (strcmp(ptr, "") != 0) {
			
			*new_token = malloc(strlen(variable)+ strlen(ptr) +2); //El 1 es del '/0' y otro por el "/"

			if (*new_token != NULL) {
				write_newtoken(*&new_token ,variable, ptr);
				
			} else {
				memLocateFailed();
			}		
				
		} else {
			*new_token = strdup(variable);
		}
		
/*
		if (ptr != NULL) {
			free(new_token);
			printf("se ha ejecutado esto?\n");
		}*/
		
}

void
sust_vars(char **token) { //SE ENCARGA DE SUSTITUIR UNA VARIABLE DE ENTORNO EN EL TOKEN, Y DEJARLO INTACTO
	
	char *ptr = *token;
	char *found = NULL;
	char *variable;
	char *delimiter = "/";
	char *new_token;

	ptr = strchr(ptr, '$');
	ptr++; //AVANCAMOS UNA POSICION, ES DECIR AL SIGUIENTE CARACTER DESPUES DE $
	found = get_next_token(ptr, delimiter); // BUSCAMOS LA PALABRA DELIMITADA, EN CASO DE QUE HAYA ALGO DESPUES DE LA VAR
	if (found != NULL) {
		
		// OBTENEMOS EL TEXTO DESPUES DE LA PALABRA ENCONTRADA
		ptr = ptr + (strlen(found)+1); // EL 1 ES DEL 
		variable = get_variable(found);
		remake_token(&new_token, variable, ptr); //RECONSTRUIMOS EL TOKEN, CON LA VARIABLE YA SUSTITUIDA

        //free(*token);
		printf("valor actual de token: %s.\n", *token);
		//free(*token);
		*token = realloc(*token,sizeof(*new_token));
		//**token = *new_token; //ASIGNAMOS DIRECTAMENTE EL STRING, NO TRABAJAMOS CON DIRS DE MEMORIA
		printf("valor actual de token: %s.\n", *token);
		free(new_token);
		
	} else {
		//free(*token);
		*token = strdup("$");
	}

	
	

}

void
tokenizator(char *line, Commands *cmds) 
{
    
	char *token;
	char *saveptr;

	
	//SETEAMOS EL PRIMER COMANDO
	if (reserve_commands(cmds) == NULL) {
		// Manejar el error de asignación de memoria
		memLocateFailed();

		return;
	}
		
	token = strtok_r(line, " ", &saveptr); //Token es una dir de memoria

	while (token != NULL) {

		if (cmds->comandos[cmds->numCommands]->numArgumentos != 0) {
			token = strtok_r(NULL, " ", &saveptr);
		}

		if (token != NULL) {

			// ......... Codigo destinado a la sustitucion de ENV VARS ..........................
			printf("tamaño de token %ld .\n", sizeof(token));
			envar_detector(cmds, &token);
			printf("tamaño de token %ld .\n", sizeof(token));
			// ...............................................................
			// ......... Codigo destinado al globbing ..........................	
	
			if (is_glob(token) != 0) {
				
				globbing_detector(cmds, token, saveptr);
				
			} else {
				instruction_classifier(cmds, &token, &saveptr);
			}		
			// ...............................................................
        }
    }
	
    setLastArgumentNull(cmds->comandos[cmds->numCommands]);
    cmds->numCommands++;
	free(token);
}

